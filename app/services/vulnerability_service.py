import asyncio
import aiohttp
from typing import List, Dict, Any, Optional
from datetime import datetime
import json

from ..models.dependency import Dependency
from ..models.vulnerability import Vulnerability


class VulnerabilityService:
    """Service for querying vulnerability databases"""

    def __init__(self, osv_api_url: str = "https://api.osv.dev"):
        self.osv_api_url = osv_api_url.rstrip('/')
        self.session = None

    async def __aenter__(self):
        self.session = aiohttp.ClientSession()
        return self

    async def __aexit__(self, exc_type, exc_val, exc_tb):
        if self.session:
            await self.session.close()

    async def get_vulnerabilities_for_dependency(self, dependency: Dependency) -> List[Vulnerability]:
        """
        Get vulnerabilities for a single dependency

        Args:
            dependency: The dependency to check

        Returns:
            List of vulnerabilities affecting this dependency
        """
        if not self.session:
            raise RuntimeError("VulnerabilityService must be used as async context manager")

        query = {
            "package": {
                "name": dependency.name,
                "ecosystem": self._get_ecosystem(dependency.dependency_type)
            }
        }

        try:
            data = await self._make_api_request(query)
            return [self._parse_vulnerability(vuln) for vuln in data.get("vulns", [])]
        except Exception as e:
            print(f"Exception querying OSV API for {dependency.name}: {e}")
            return []

    async def _make_api_request(self, query: Dict[str, Any]) -> Dict[str, Any]:
        """Make an API request to OSV.dev"""
        async with self.session.post(
            f"{self.osv_api_url}/v1/query",
            json=query,
            headers={"Content-Type": "application/json"}
        ) as response:
            if response.status == 200:
                return await response.json()
            else:
                # Log error but don't fail the entire analysis
                print(f"Error querying OSV API: {response.status}")
                return {"vulns": []}

    async def get_vulnerabilities_batch(self, dependencies: List[Dependency]) -> Dict[str, List[Vulnerability]]:
        """
        Get vulnerabilities for multiple dependencies in parallel

        Args:
            dependencies: List of dependencies to check

        Returns:
            Dictionary mapping dependency names to their vulnerabilities
        """
        if not self.session:
            raise RuntimeError("VulnerabilityService must be used as async context manager")

        # Create tasks for parallel execution
        tasks = []
        for dep in dependencies:
            task = self.get_vulnerabilities_for_dependency(dep)
            tasks.append((dep.name, task))

        # Execute all queries in parallel
        results = {}
        for dep_name, task in tasks:
            try:
                vulnerabilities = await task
                results[dep_name] = vulnerabilities
            except Exception as e:
                print(f"Error getting vulnerabilities for {dep_name}: {e}")
                results[dep_name] = []

        return results

    def _get_ecosystem(self, dependency_type: str) -> str:
        """Map dependency type to OSV ecosystem name"""
        ecosystem_map = {
            "npm": "npm",
            "python": "PyPI"
        }
        return ecosystem_map.get(dependency_type, dependency_type)

    def _parse_vulnerability(self, vuln_data: Dict[str, Any]) -> Vulnerability:
        """Parse vulnerability data from OSV API response"""
        # Parse affected packages
        affected_packages = []
        for affected in vuln_data.get("affected", []):
            package_info = affected.get("package", {})
            affected_packages.append({
                "name": package_info.get("name"),
                "ecosystem": package_info.get("ecosystem"),
                "purl": package_info.get("purl")
            })

        # Parse references
        references = []
        for ref in vuln_data.get("references", []):
            references.append({
                "url": ref.get("url"),
                "type": ref.get("type")
            })

        # Parse dates
        published = None
        if vuln_data.get("published"):
            try:
                published = datetime.fromisoformat(vuln_data["published"].replace("Z", "+00:00"))
            except ValueError:
                pass

        modified = None
        if vuln_data.get("modified"):
            try:
                modified = datetime.fromisoformat(vuln_data["modified"].replace("Z", "+00:00"))
            except ValueError:
                pass

        return Vulnerability(
            id=vuln_data.get("id", ""),
            summary=vuln_data.get("summary", ""),
            description=vuln_data.get("details"),
            severity=vuln_data.get("database_specific", {}).get("severity"),
            affected_packages=affected_packages,
            references=references,
            published=published,
            modified=modified,
            database_specific=vuln_data.get("database_specific", {})
        )

    def is_vulnerability_affecting_version(self, vulnerability: Vulnerability, dependency: Dependency) -> bool:
        """
        Check if a vulnerability affects the specific version of a dependency

        Args:
            vulnerability: The vulnerability to check
            dependency: The dependency to check against

        Returns:
            True if the vulnerability affects this version
        """
        # This is a simplified check - in a real implementation, you'd want to use
        # proper version range parsing and comparison
        for affected in vulnerability.affected_packages:
            if affected.get("name") == dependency.name:
                # For now, assume it affects the version if the package name matches
                # In a real implementation, you'd check version ranges
                return True

        return False

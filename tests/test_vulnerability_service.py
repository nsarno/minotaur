import pytest
import aiohttp
from unittest.mock import AsyncMock, patch, MagicMock
from datetime import datetime

from app.services.vulnerability_service import VulnerabilityService
from app.models.dependency import Dependency, DependencyType
from app.models.vulnerability import Vulnerability


class TestVulnerabilityService:
    """Test cases for VulnerabilityService"""

    @pytest.fixture
    def service(self):
        return VulnerabilityService(osv_api_url="https://api.osv.dev")

    @pytest.fixture
    def sample_dependency(self):
        return Dependency(
            name="requests",
            version="2.25.0",
            dependency_type=DependencyType.PYTHON,
            is_direct=True
        )

    @pytest.fixture
    def sample_vulnerability_data(self):
        return {
            "id": "CVE-2023-1234",
            "summary": "Test vulnerability in requests",
            "details": "This is a test vulnerability description",
            "severity": "HIGH",
            "affected": [
                {
                    "package": {
                        "name": "requests",
                        "ecosystem": "PyPI",
                        "purl": "pkg:pypi/requests"
                    }
                }
            ],
            "references": [
                {
                    "url": "https://example.com/cve-2023-1234",
                    "type": "ADVISORY"
                }
            ],
            "published": "2023-01-01T00:00:00Z",
            "modified": "2023-01-02T00:00:00Z",
            "database_specific": {
                "severity": "HIGH"
            }
        }

    @pytest.mark.asyncio
    async def test_get_ecosystem_mapping(self, service):
        """Test ecosystem mapping for different dependency types"""
        assert service._get_ecosystem("npm") == "npm"
        assert service._get_ecosystem("python") == "PyPI"
        assert service._get_ecosystem("unknown") == "unknown"

    def test_parse_vulnerability(self, service, sample_vulnerability_data):
        """Test parsing vulnerability data from OSV API"""
        vuln = service._parse_vulnerability(sample_vulnerability_data)

        assert vuln.id == "CVE-2023-1234"
        assert vuln.summary == "Test vulnerability in requests"
        assert vuln.description == "This is a test vulnerability description"
        assert vuln.severity == "HIGH"
        assert len(vuln.affected_packages) == 1
        assert vuln.affected_packages[0]["name"] == "requests"
        assert len(vuln.references) == 1
        assert vuln.references[0]["url"] == "https://example.com/cve-2023-1234"
        assert vuln.published is not None
        assert vuln.modified is not None

    def test_parse_vulnerability_missing_fields(self, service):
        """Test parsing vulnerability with missing optional fields"""
        minimal_data = {
            "id": "CVE-2023-1234",
            "summary": "Test vulnerability"
        }

        vuln = service._parse_vulnerability(minimal_data)

        assert vuln.id == "CVE-2023-1234"
        assert vuln.summary == "Test vulnerability"
        assert vuln.description is None
        assert vuln.severity is None
        assert vuln.affected_packages == []
        assert vuln.references == []
        assert vuln.published is None
        assert vuln.modified is None

    def test_is_vulnerability_affecting_version(self, service, sample_dependency):
        """Test checking if vulnerability affects a specific version"""
        # Create vulnerability that affects the dependency
        vuln_data = {
            "affected": [
                {
                    "package": {
                        "name": "requests",
                        "ecosystem": "PyPI"
                    }
                }
            ]
        }
        vuln = service._parse_vulnerability(vuln_data)

        assert service.is_vulnerability_affecting_version(vuln, sample_dependency) is True

        # Create vulnerability that doesn't affect the dependency
        vuln_data_no_match = {
            "affected": [
                {
                    "package": {
                        "name": "different-package",
                        "ecosystem": "PyPI"
                    }
                }
            ]
        }
        vuln_no_match = service._parse_vulnerability(vuln_data_no_match)

        assert service.is_vulnerability_affecting_version(vuln_no_match, sample_dependency) is False

    @pytest.mark.asyncio
    async def test_get_vulnerabilities_for_dependency_success(self, service, sample_dependency, sample_vulnerability_data):
        """Test successful vulnerability query"""
        # Set up a mock session
        service.session = MagicMock()

        # Mock the entire method to avoid complex async context manager mocking
        with patch.object(service, '_make_api_request') as mock_request:
            mock_request.return_value = {"vulns": [sample_vulnerability_data]}

            vulnerabilities = await service.get_vulnerabilities_for_dependency(sample_dependency)

            assert len(vulnerabilities) == 1
            assert vulnerabilities[0].id == "CVE-2023-1234"
            assert vulnerabilities[0].summary == "Test vulnerability in requests"

    @pytest.mark.asyncio
    async def test_get_vulnerabilities_for_dependency_error(self, service, sample_dependency):
        """Test vulnerability query with API error"""
        # Set up a mock session
        service.session = MagicMock()

        # Mock the entire method to avoid complex async context manager mocking
        with patch.object(service, '_make_api_request') as mock_request:
            mock_request.side_effect = Exception("API Error")

            vulnerabilities = await service.get_vulnerabilities_for_dependency(sample_dependency)

            # Should return empty list on error
            assert vulnerabilities == []

    @pytest.mark.asyncio
    async def test_get_vulnerabilities_batch(self, service):
        """Test batch vulnerability query"""
        dependencies = [
            Dependency(name="requests", version="2.25.0", dependency_type=DependencyType.PYTHON, is_direct=True),
            Dependency(name="express", version="4.17.1", dependency_type=DependencyType.NPM, is_direct=True)
        ]

        # Set up a mock session
        service.session = MagicMock()

        # Mock responses for each dependency
        mock_responses = {
            "requests": {"vulns": [{"id": "CVE-1", "summary": "Vuln 1"}]},
            "express": {"vulns": [{"id": "CVE-2", "summary": "Vuln 2"}]}
        }

        # Mock the entire method to avoid complex async context manager mocking
        with patch.object(service, '_make_api_request') as mock_request:
            def mock_request_side_effect(query):
                # Determine which dependency this request is for
                if "requests" in str(query):
                    return mock_responses["requests"]
                else:
                    return mock_responses["express"]

            mock_request.side_effect = mock_request_side_effect

            results = await service.get_vulnerabilities_batch(dependencies)

            assert "requests" in results
            assert "express" in results
            assert len(results["requests"]) == 1
            assert len(results["express"]) == 1
            assert results["requests"][0].id == "CVE-1"
            assert results["express"][0].id == "CVE-2"

    @pytest.mark.asyncio
    async def test_context_manager(self, service):
        """Test that service works as async context manager"""
        mock_session = MagicMock()
        mock_session.__aenter__ = AsyncMock(return_value=mock_session)
        mock_session.__aexit__ = AsyncMock(return_value=None)
        mock_session.close = AsyncMock()

        with patch('aiohttp.ClientSession', return_value=mock_session):
            async with service as svc:
                assert svc.session == mock_session

            # Session should be closed
            mock_session.close.assert_called_once()
